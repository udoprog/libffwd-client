// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/protocol0.proto

#ifndef PROTOBUF_proto_2fprotocol0_2eproto__INCLUDED
#define PROTOBUF_proto_2fprotocol0_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace FFWD {
namespace Protocol0 {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_proto_2fprotocol0_2eproto();
void protobuf_AssignDesc_proto_2fprotocol0_2eproto();
void protobuf_ShutdownFile_proto_2fprotocol0_2eproto();

class Metric;
class Event;
class Attribute;
class Message;

// ===================================================================

class Metric : public ::google::protobuf::Message {
 public:
  Metric();
  virtual ~Metric();

  Metric(const Metric& from);

  inline Metric& operator=(const Metric& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Metric& default_instance();

  void Swap(Metric* other);

  // implements Message ----------------------------------------------

  Metric* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Metric& from);
  void MergeFrom(const Metric& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string proc = 1;
  inline bool has_proc() const;
  inline void clear_proc();
  static const int kProcFieldNumber = 1;
  inline const ::std::string& proc() const;
  inline void set_proc(const ::std::string& value);
  inline void set_proc(const char* value);
  inline void set_proc(const char* value, size_t size);
  inline ::std::string* mutable_proc();
  inline ::std::string* release_proc();
  inline void set_allocated_proc(::std::string* proc);

  // optional int64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional double value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline double value() const;
  inline void set_value(double value);

  // optional string host = 5;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 5;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // repeated string tags = 6;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 6;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // repeated .FFWD.Protocol0.Attribute attributes = 7;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 7;
  inline const ::FFWD::Protocol0::Attribute& attributes(int index) const;
  inline ::FFWD::Protocol0::Attribute* mutable_attributes(int index);
  inline ::FFWD::Protocol0::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::FFWD::Protocol0::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::FFWD::Protocol0::Attribute >*
      mutable_attributes();

  // @@protoc_insertion_point(class_scope:FFWD.Protocol0.Metric)
 private:
  inline void set_has_proc();
  inline void clear_has_proc();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_host();
  inline void clear_has_host();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* proc_;
  ::google::protobuf::int64 time_;
  ::std::string* key_;
  double value_;
  ::std::string* host_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::FFWD::Protocol0::Attribute > attributes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol0_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol0_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol0_2eproto();

  void InitAsDefaultInstance();
  static Metric* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  void Swap(Event* other);

  // implements Message ----------------------------------------------

  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional double value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline double value() const;
  inline void set_value(double value);

  // optional string host = 4;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 4;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional string state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional int64 ttl = 7;
  inline bool has_ttl() const;
  inline void clear_ttl();
  static const int kTtlFieldNumber = 7;
  inline ::google::protobuf::int64 ttl() const;
  inline void set_ttl(::google::protobuf::int64 value);

  // repeated string tags = 8;
  inline int tags_size() const;
  inline void clear_tags();
  static const int kTagsFieldNumber = 8;
  inline const ::std::string& tags(int index) const;
  inline ::std::string* mutable_tags(int index);
  inline void set_tags(int index, const ::std::string& value);
  inline void set_tags(int index, const char* value);
  inline void set_tags(int index, const char* value, size_t size);
  inline ::std::string* add_tags();
  inline void add_tags(const ::std::string& value);
  inline void add_tags(const char* value);
  inline void add_tags(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // repeated .FFWD.Protocol0.Attribute attributes = 9;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 9;
  inline const ::FFWD::Protocol0::Attribute& attributes(int index) const;
  inline ::FFWD::Protocol0::Attribute* mutable_attributes(int index);
  inline ::FFWD::Protocol0::Attribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::FFWD::Protocol0::Attribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::FFWD::Protocol0::Attribute >*
      mutable_attributes();

  // @@protoc_insertion_point(class_scope:FFWD.Protocol0.Event)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_ttl();
  inline void clear_has_ttl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* key_;
  double value_;
  ::std::string* host_;
  ::std::string* state_;
  ::std::string* description_;
  ::google::protobuf::int64 ttl_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::FFWD::Protocol0::Attribute > attributes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol0_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol0_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol0_2eproto();

  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class Attribute : public ::google::protobuf::Message {
 public:
  Attribute();
  virtual ~Attribute();

  Attribute(const Attribute& from);

  inline Attribute& operator=(const Attribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Attribute& default_instance();

  void Swap(Attribute* other);

  // implements Message ----------------------------------------------

  Attribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Attribute& from);
  void MergeFrom(const Attribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:FFWD.Protocol0.Attribute)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol0_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol0_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol0_2eproto();

  void InitAsDefaultInstance();
  static Attribute* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .FFWD.Protocol0.Metric metric = 1;
  inline bool has_metric() const;
  inline void clear_metric();
  static const int kMetricFieldNumber = 1;
  inline const ::FFWD::Protocol0::Metric& metric() const;
  inline ::FFWD::Protocol0::Metric* mutable_metric();
  inline ::FFWD::Protocol0::Metric* release_metric();
  inline void set_allocated_metric(::FFWD::Protocol0::Metric* metric);

  // optional .FFWD.Protocol0.Event event = 2;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 2;
  inline const ::FFWD::Protocol0::Event& event() const;
  inline ::FFWD::Protocol0::Event* mutable_event();
  inline ::FFWD::Protocol0::Event* release_event();
  inline void set_allocated_event(::FFWD::Protocol0::Event* event);

  // @@protoc_insertion_point(class_scope:FFWD.Protocol0.Message)
 private:
  inline void set_has_metric();
  inline void clear_has_metric();
  inline void set_has_event();
  inline void clear_has_event();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::FFWD::Protocol0::Metric* metric_;
  ::FFWD::Protocol0::Event* event_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_proto_2fprotocol0_2eproto();
  friend void protobuf_AssignDesc_proto_2fprotocol0_2eproto();
  friend void protobuf_ShutdownFile_proto_2fprotocol0_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// Metric

// optional string proc = 1;
inline bool Metric::has_proc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Metric::set_has_proc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Metric::clear_has_proc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Metric::clear_proc() {
  if (proc_ != &::google::protobuf::internal::kEmptyString) {
    proc_->clear();
  }
  clear_has_proc();
}
inline const ::std::string& Metric::proc() const {
  return *proc_;
}
inline void Metric::set_proc(const ::std::string& value) {
  set_has_proc();
  if (proc_ == &::google::protobuf::internal::kEmptyString) {
    proc_ = new ::std::string;
  }
  proc_->assign(value);
}
inline void Metric::set_proc(const char* value) {
  set_has_proc();
  if (proc_ == &::google::protobuf::internal::kEmptyString) {
    proc_ = new ::std::string;
  }
  proc_->assign(value);
}
inline void Metric::set_proc(const char* value, size_t size) {
  set_has_proc();
  if (proc_ == &::google::protobuf::internal::kEmptyString) {
    proc_ = new ::std::string;
  }
  proc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Metric::mutable_proc() {
  set_has_proc();
  if (proc_ == &::google::protobuf::internal::kEmptyString) {
    proc_ = new ::std::string;
  }
  return proc_;
}
inline ::std::string* Metric::release_proc() {
  clear_has_proc();
  if (proc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = proc_;
    proc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Metric::set_allocated_proc(::std::string* proc) {
  if (proc_ != &::google::protobuf::internal::kEmptyString) {
    delete proc_;
  }
  if (proc) {
    set_has_proc();
    proc_ = proc;
  } else {
    clear_has_proc();
    proc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 time = 2;
inline bool Metric::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Metric::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Metric::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Metric::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Metric::time() const {
  return time_;
}
inline void Metric::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string key = 3;
inline bool Metric::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Metric::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Metric::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Metric::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Metric::key() const {
  return *key_;
}
inline void Metric::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Metric::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Metric::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Metric::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Metric::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Metric::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double value = 4;
inline bool Metric::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Metric::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Metric::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Metric::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Metric::value() const {
  return value_;
}
inline void Metric::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional string host = 5;
inline bool Metric::has_host() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Metric::set_has_host() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Metric::clear_has_host() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Metric::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& Metric::host() const {
  return *host_;
}
inline void Metric::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void Metric::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void Metric::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Metric::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* Metric::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Metric::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string tags = 6;
inline int Metric::tags_size() const {
  return tags_.size();
}
inline void Metric::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Metric::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* Metric::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void Metric::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void Metric::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void Metric::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Metric::add_tags() {
  return tags_.Add();
}
inline void Metric::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void Metric::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void Metric::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Metric::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Metric::mutable_tags() {
  return &tags_;
}

// repeated .FFWD.Protocol0.Attribute attributes = 7;
inline int Metric::attributes_size() const {
  return attributes_.size();
}
inline void Metric::clear_attributes() {
  attributes_.Clear();
}
inline const ::FFWD::Protocol0::Attribute& Metric::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::FFWD::Protocol0::Attribute* Metric::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::FFWD::Protocol0::Attribute* Metric::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FFWD::Protocol0::Attribute >&
Metric::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::FFWD::Protocol0::Attribute >*
Metric::mutable_attributes() {
  return &attributes_;
}

// -------------------------------------------------------------------

// Event

// optional int64 time = 1;
inline bool Event::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Event::time() const {
  return time_;
}
inline void Event::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional string key = 2;
inline bool Event::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Event::key() const {
  return *key_;
}
inline void Event::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Event::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Event::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Event::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Event::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double value = 3;
inline bool Event::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Event::value() const {
  return value_;
}
inline void Event::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional string host = 4;
inline bool Event::has_host() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Event::set_has_host() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Event::clear_has_host() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Event::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& Event::host() const {
  return *host_;
}
inline void Event::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void Event::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void Event::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* Event::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Event::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string state = 5;
inline bool Event::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Event::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Event::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Event::clear_state() {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& Event::state() const {
  return *state_;
}
inline void Event::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void Event::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void Event::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* Event::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Event::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 6;
inline bool Event::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Event::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Event::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Event::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& Event::description() const {
  return *description_;
}
inline void Event::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Event::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void Event::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* Event::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Event::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 ttl = 7;
inline bool Event::has_ttl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Event::set_has_ttl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Event::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Event::clear_ttl() {
  ttl_ = GOOGLE_LONGLONG(0);
  clear_has_ttl();
}
inline ::google::protobuf::int64 Event::ttl() const {
  return ttl_;
}
inline void Event::set_ttl(::google::protobuf::int64 value) {
  set_has_ttl();
  ttl_ = value;
}

// repeated string tags = 8;
inline int Event::tags_size() const {
  return tags_.size();
}
inline void Event::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Event::tags(int index) const {
  return tags_.Get(index);
}
inline ::std::string* Event::mutable_tags(int index) {
  return tags_.Mutable(index);
}
inline void Event::set_tags(int index, const ::std::string& value) {
  tags_.Mutable(index)->assign(value);
}
inline void Event::set_tags(int index, const char* value) {
  tags_.Mutable(index)->assign(value);
}
inline void Event::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Event::add_tags() {
  return tags_.Add();
}
inline void Event::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
}
inline void Event::add_tags(const char* value) {
  tags_.Add()->assign(value);
}
inline void Event::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Event::tags() const {
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Event::mutable_tags() {
  return &tags_;
}

// repeated .FFWD.Protocol0.Attribute attributes = 9;
inline int Event::attributes_size() const {
  return attributes_.size();
}
inline void Event::clear_attributes() {
  attributes_.Clear();
}
inline const ::FFWD::Protocol0::Attribute& Event::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::FFWD::Protocol0::Attribute* Event::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::FFWD::Protocol0::Attribute* Event::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FFWD::Protocol0::Attribute >&
Event::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::FFWD::Protocol0::Attribute >*
Event::mutable_attributes() {
  return &attributes_;
}

// -------------------------------------------------------------------

// Attribute

// required string key = 1;
inline bool Attribute::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attribute::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attribute::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attribute::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Attribute::key() const {
  return *key_;
}
inline void Attribute::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Attribute::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Attribute::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attribute::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Attribute::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Attribute::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool Attribute::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attribute::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attribute::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attribute::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Attribute::value() const {
  return *value_;
}
inline void Attribute::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Attribute::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Attribute::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Attribute::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Attribute::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Attribute::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Message

// optional .FFWD.Protocol0.Metric metric = 1;
inline bool Message::has_metric() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_metric() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_metric() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_metric() {
  if (metric_ != NULL) metric_->::FFWD::Protocol0::Metric::Clear();
  clear_has_metric();
}
inline const ::FFWD::Protocol0::Metric& Message::metric() const {
  return metric_ != NULL ? *metric_ : *default_instance_->metric_;
}
inline ::FFWD::Protocol0::Metric* Message::mutable_metric() {
  set_has_metric();
  if (metric_ == NULL) metric_ = new ::FFWD::Protocol0::Metric;
  return metric_;
}
inline ::FFWD::Protocol0::Metric* Message::release_metric() {
  clear_has_metric();
  ::FFWD::Protocol0::Metric* temp = metric_;
  metric_ = NULL;
  return temp;
}
inline void Message::set_allocated_metric(::FFWD::Protocol0::Metric* metric) {
  delete metric_;
  metric_ = metric;
  if (metric) {
    set_has_metric();
  } else {
    clear_has_metric();
  }
}

// optional .FFWD.Protocol0.Event event = 2;
inline bool Message::has_event() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_event() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_event() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_event() {
  if (event_ != NULL) event_->::FFWD::Protocol0::Event::Clear();
  clear_has_event();
}
inline const ::FFWD::Protocol0::Event& Message::event() const {
  return event_ != NULL ? *event_ : *default_instance_->event_;
}
inline ::FFWD::Protocol0::Event* Message::mutable_event() {
  set_has_event();
  if (event_ == NULL) event_ = new ::FFWD::Protocol0::Event;
  return event_;
}
inline ::FFWD::Protocol0::Event* Message::release_event() {
  clear_has_event();
  ::FFWD::Protocol0::Event* temp = event_;
  event_ = NULL;
  return temp;
}
inline void Message::set_allocated_event(::FFWD::Protocol0::Event* event) {
  delete event_;
  event_ = event;
  if (event) {
    set_has_event();
  } else {
    clear_has_event();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol0
}  // namespace FFWD

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fprotocol0_2eproto__INCLUDED
